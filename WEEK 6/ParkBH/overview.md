# 집합, 해시, 이진 검색 트리

### 💡 필수 내용

- **집합 (Set)**
  + 중복을 허용하지 않고, 특정 원소가 있는지 빠르게 찾을 수 있는 구조

- **해시 (Hash)**
  + 데이터를 빠르게 저장하고 검색하기 위해 사용하는 기술

- **이진 검색 트리 (BST)**
  + 이진 트리의 한 종류
  + 배열, 리스트보다 탐색, 삽입, 삭제에 효율적

- **알아야 하는 클래스**
  + `HashSet`, `HashMap`
  + `TreeSet`, `TreeMap`


<br/>

### ❓ 유용한 내용

- 레드-블랙 트리 (Red-Black Tree)

  + 일반 BST는 한쪽으로 치우칠 경우 $O(N)$의 성능 저하가 발생할 수 있다
  + RBT는 균형을 유지하는 자체적인 규칙을 가진 BST으로, 탐색, 삽입, 삭제를 $O(log N)$으로 유지한다
  + `TreeSet`과 `TreeMap`가 RBT로 구현되어 있다

- 함께 알아두면 좋은 자료구조

  + `LinkedHashSet` : 입력 순서를 유지하면서 저장
  + `LinkedHashMap` : 입력 순서를 유지하면서 Key-Value 저장
  + `PriorityQueue` : 최솟값, 최댓값을 빠르게 찾아야 할 때 사용



<br/>

### ❓ 이번주 학습을 통해 느낀 점
## HASH
### 특징
- **검색 속도**: 데이터를 저장할 때 해시 함수를 사용하여 특정 위치에 데이터를 저장하므로, 평균적으로 매우 빠른 O(1) 시간 복잡도를 가집니다.
- **중복 허용 여부**:
  - **HashSet**: 중복을 허용하지 않음.
  - **HashMap**: 키는 중복을 허용하지 않지만, 값은 중복을 허용함.
  - (키마다 다른 변수로 연산을 해야하는 문제라면 HASHMAP을 쓰는게 좋을 듯 나무 문제 같이 )
- **순서 없음**: 해시 구조는 데이터를 저장한 순서를 보장하지 않음. 즉, 저장된 데이터의 순서와 관계없이 접근할 수 있다.


## TreeSet

`TreeSet`은 `Set` 인터페이스를 구현한 클래스 중 하나로, 내부적으로 이진 검색 트리(Binary Search Tree)인 `Red-Black Tree`를 사용합니다. `TreeSet`은 저장된 데이터를 자동으로 정렬된 상태로 유지하며, `HashSet`과 달리 요소들의 순서가 보장됩니다.

### 특징
- **자동 정렬**: `TreeSet`은 데이터를 삽입할 때 자동으로 오름차순으로 정렬합니다.
- (그래서 문제를 풀 때 정렬이 필요하다면 다른 자료 구조에 넣고 SORT하는 것보다 TReeset을 쓰는게 나을지도?)
- **검색 속도**: 평균적으로 O(log N)의 시간 복잡도를 가집니다. 해시 기반의 `HashSet`보다 다소 느릴 수 있다고 GPT가 말함.
- **중복 허용 여부**: `TreeSet`은 중복을 허용하지 않으며, 중복된 값은 저장되지 않습니다.
- **순서 보장**: 데이터가 항상 정렬된 순서로 저장되고 출력됩니다.


