# **[Week 7] Backtracking, Bitmask**

### 1. 백트래킹 (Backtracking)
- '모든 경우의 수를 탐색'하는 기법
- 불필요한 탐색을 줄이기 위해 '가지치기(Pruning)'를 활용하는 방식
- 정답이 될 가능성이 없는 경우는 더 이상 탐색하지 않고 되돌아가 다음 경우를 탐색색

#### 활용되는 문제 유형
1. 순열(Permutation): 서로 다른 n개의 원소를 순서를 고려하여 나열
2. 조합(Combination): n개의 원소 중 일부를 선택
3. 부분집합(Subsets): 주어진 집합의 모든 부분집합을 찾는 문제
4. N-Queen 문제: 퀸을 서로 공격하지 않도록 N×N 체스판에 배치하는 문제
5. 미로 탐색: 특정 경로를 따라 이동할 때, 올바른 경로를 찾는 문제
6. DFS(깊이 우선 탐색) 기반 탐색 문제: 그래프나 트리를 탐색하는 문제에서 백트래킹을 활용할 수 있음

### 2. 비트마스크 (Bitmask)
- 정수의 이진 표현(0과 1)을 활용하여 집합을 표현하는 기법
- 주로 int형(32bit) 또는 long형(64bit) 변수 활용 -> 원소의 존재 여부를 표현현

#### 활용되는 문제 유형
1. 부분집합(Subset) 생성: 비트마스크를 활용해 부분집합을 빠르게 생성 가능
2. 조합(Combination) 계산: 특정 원소를 선택하는 경우를 비트 연산으로 표현
3. N-Queen 최적화: 행, 열, 대각선 공격을 비트마스크로 빠르게 체크
4. 비트 DP(Dynamic Programming): 상태를 비트마스크로 저장하여 활용하는 최적화 문제
5. 비트 연산을 활용한 효율적 탐색: 특정 조건을 만족하는 경우의 수 계산

#### 주요 연산
| 연산 | 연산자 | 예시 (A = `1011`) |
| --- | --- | --- |
| 특정 비트 켜기(1로 설정) | `A | (1 << i)` |
| 특정 비트 끄기(0으로 설정) | `A & ~(1 << i)` | `A & ~(1 << 1) → 1011 & 1101 = 1001` |
| 특정 비트 토글(반전) | `A ^ (1 << i)` | `A ^ (1 << 0) → 1011 ^ 0001 = 1010` |
| 특정 비트 확인 | `(A & (1 << i)) != 0` | `A & (1 << 2) → 1011 & 0100 = 0100 (true)` |
| 모든 부분집합 탐색 | `for (int subset = A; subset > 0; subset = (subset - 1) & A)` |  |