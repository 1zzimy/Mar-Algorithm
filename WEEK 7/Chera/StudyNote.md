## 비트 마스킹

**가장 우측의 비트를 1번째 비트라고 하자.**
**이 때, i번째 비트에 가할 수 있는 연산은 다음과 같다.**

- i번째 비트 조회
    - n & (1 << (i-1))
- i번째 비트를 1로 변경
    - n | (1 << (i-1))
- i번째 비트를 0으로 변경
    - n & ~(1 << (i-1))

### 비트 마스킹의 장점
정수의 2진수 표현을 자료구조로 쓰는 기법

- 수행시간이 빠름
    - 비트 연산이기 때문에 O(1)에 구현되는 것이 많음. 
    - 원소의 수가 많지 않다는 뜻이기 때문에 큰 속도 향상을 기대할 수는 없지만, 여러번 수행해야 하는 경우, 큰 속도 향상을 가져올 수 있음
- 코드가 간결해짐
    - 조건문, 반복문을 사용하지 않고 다양한 집합 연산들을 통해 코드를 간결하게 작성할 수 있음
- 적은 메모리를 사용
    - 하나의 정수로 많은 경우의 수를 표현할 수 있기 때문에 메모리 측면에서 효율적이며, 더 많은 데이터를 미리 계산하여 저장해 둘 수 있다는 장점이 있음
    - DP에 매우 유용

### 비트마스킹을 이용한 배열의 부분집합 구하기
```java
int[] arr = {1, 2, 3, 4, 5};

for (int i = 0; i < 1 << arr.length; i++) {
    // Integer.bitCount(k) : k를 이진수로 표현했을 때 1의 개수 리턴
    if (Integer.bitCount(i) == 2) {
        for (int j = 0; j < arr.length; j++) {
            if ((i & (1 << j)) > 0) {
                System.out.printf("%2d", arr[j]);
            }
        }
        System.out.println();
    }
}
```